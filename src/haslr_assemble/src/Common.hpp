/*****************************************************
 * Author: Ehsan Haghshenas (ehaghshe AT sfu DOT ca) *
 *****************************************************/

#ifndef __COMMON__
#define __COMMON__

#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <unistd.h>
#include <stdint.h>
#include <algorithm>
#include <thread>

#define VERBOSITY 0

#if VERBOSITY < 1
#define LOG1(cmd)
#define LOG2(cmd)
#define LOG3(cmd)
#elif VERBOSITY < 2
#define LOG1(cmd) cmd
#define LOG2(cmd)
#define LOG3(cmd)
#elif VERBOSITY < 3
#define LOG1(cmd) cmd
#define LOG2(cmd) cmd
#define LOG3(cmd)
#elif VERBOSITY >= 3
#define LOG1(cmd) cmd
#define LOG2(cmd) cmd
#define LOG3(cmd) cmd
#endif

using namespace std;

typedef struct
{
    // Command line parameters
    string contig_path; // path to the contigs file constructed by bcalm
    string long_path; // path to the long read dataset
    bool long_fofn;
    string mapping_path; //  path to mapping of long reads onto contigs generated by minimap2
    bool mapping_fofn;
    string out_dir;
    // string ref_path; // path to the reference genome fasta file
    // string shortPath; // path to the short read dataset
    uint32_t min_aln_block; // minimum alignment block size
    double min_aln_sim; // minimum alignment similarity
    uint8_t min_aln_mapq; // minimum alignment MAPQ
    double max_uniq_dev; // maximum deviation from mean frequency
    uint32_t min_edge_sup; // minimum support for each edge
    uint32_t num_threads;
    string prog_version;
    // Other global parameters
    double uniq_freq;
} global_options_t;
extern global_options_t gopt;

struct id_strand_t
{
    uint32_t strand : 1;
    uint32_t is_tail : 1;
    uint32_t id : 30;

    bool operator< (const id_strand_t& lhs) const
    {
        return this->id < lhs.id;
        // if(this->id < lhs.id) return true;
        // if(this->id > lhs.id) return false;
        // return this->strand < lhs.strand;
    }

    // bool operator< (const id_strand_t& lhs) const
    // {
    //     return *(uint32_t*)this < *(uint32_t*)&lhs;
    // }
};

struct id_strand2_t
{
    uint32_t strand : 1;
    uint32_t id : 31;

    bool operator< (const id_strand2_t& lhs) const
    {
        // return this->id < lhs.id;
        if(this->id < lhs.id) return true;
        if(this->id > lhs.id) return false;
        return this->strand < lhs.strand;
    }
};

struct path_elem_t
{
    uint32_t strand : 1;         // the strand of short read contig
    uint32_t id : 30;            // id of short read contig
    set<uint32_t> lrs;           // set of all long reads that align to this element
    map<uint32_t, int32_t> alns; // key: long read id - value: index of alignment in compact long read
};

// void file_clean(string path);
FILE* file_open_write(string path);
FILE* file_open_append(string path);
bool file_exists(string path);

void str_split(string str, char delim, vector<string> &v);
// counts the number of sequences in a fasta/q file
int32_t count_seqs(string path);
string expand_cigar(char *cigar);
string collapse_cigar(string cigar_exp);
double get_cpu_time();
double get_real_time();
// string str2Lower(string s);
string reverseString(string str);
string reverseComplement(string seq);
inline int check_overlap(int32_t x1, int32_t x2, int32_t y1, int32_t y2) {return x1 < y2 && y1 < x2;}

template <typename T>
T str2type(string str)
{
    T n;
    istringstream sin(str);
    sin >> n;
    return n;
}

template <typename T>
string type2str(T v)
{
    ostringstream sout;
    sout << v;
    return sout.str();
}

#endif // __COMMON__
